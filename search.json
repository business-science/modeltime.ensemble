[{"path":"https://business-science.github.io/modeltime.ensemble/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 BUSINESS SCIENCE Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"time-series-ensemble-forecasting-example","dir":"Articles","previous_headings":"","what":"Time Series Ensemble Forecasting Example","title":"Getting Started with Modeltime Ensemble","text":"’ll perform simplest type forecasting: Using simple average forecasted models. Note modeltime.ensemble capabilities sophisticated model ensembling using: Weighted Averaging Stacking using Elastic Net regression model (meta-learning)","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"libraries","dir":"Articles","previous_headings":"Time Series Ensemble Forecasting Example","what":"Libraries","title":"Getting Started with Modeltime Ensemble","text":"Load libraries complete short tutorial.","code":"# Time Series ML library(tidymodels) library(modeltime) library(modeltime.ensemble)  # Core library(tidyverse) library(timetk)  interactive <- FALSE"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"collect-the-data","dir":"Articles","previous_headings":"Time Series Ensemble Forecasting Example","what":"Collect the Data","title":"Getting Started with Modeltime Ensemble","text":"’ll use m750 dataset comes modeltime.ensemble. can visualize dataset.","code":"m750 %>%     plot_time_series(date, value, .color_var = id, .interactive = interactive)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"perform-train-test-splitting","dir":"Articles","previous_headings":"","what":"Perform Train / Test Splitting","title":"Getting Started with Modeltime Ensemble","text":"’ll split training testing set.","code":"splits <- time_series_split(m750, assess = \"2 years\", cumulative = TRUE)  splits %>%     tk_time_series_cv_plan() %>%     plot_time_series_cv_plan(date, value, .interactive = interactive)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"modeling","dir":"Articles","previous_headings":"","what":"Modeling","title":"Getting Started with Modeltime Ensemble","text":"data collected, can move modeling.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"recipe","dir":"Articles","previous_headings":"Modeling","what":"Recipe","title":"Getting Started with Modeltime Ensemble","text":"’ll create Feature Engineering Recipe can applied data create features machine learning models can key . useful Elastic Net (Model 3).","code":"recipe_spec <- recipe(value ~ date, training(splits)) %>%     step_timeseries_signature(date) %>%     step_rm(matches(\"(.iso$)|(.xts$)\")) %>%     step_normalize(matches(\"(index.num$)|(_year$)\")) %>%     step_dummy(all_nominal()) %>%     step_fourier(date, K = 1, period = 12)  recipe_spec %>% prep() %>% juice() #> # A tibble: 282 × 42 #>    date       value date_index.num date_year date_half date_quarter date_month #>    <date>     <dbl>          <dbl>     <dbl>     <int>        <int>      <int> #>  1 1990-01-01  6370          -1.72     -1.66         1            1          1 #>  2 1990-02-01  6430          -1.71     -1.66         1            1          2 #>  3 1990-03-01  6520          -1.70     -1.66         1            1          3 #>  4 1990-04-01  6580          -1.69     -1.66         1            2          4 #>  5 1990-05-01  6620          -1.67     -1.66         1            2          5 #>  6 1990-06-01  6690          -1.66     -1.66         1            2          6 #>  7 1990-07-01  6000          -1.65     -1.66         2            3          7 #>  8 1990-08-01  5450          -1.64     -1.66         2            3          8 #>  9 1990-09-01  6480          -1.62     -1.66         2            3          9 #> 10 1990-10-01  6820          -1.61     -1.66         2            4         10 #> # ℹ 272 more rows #> # ℹ 35 more variables: date_day <int>, date_hour <int>, date_minute <int>, #> #   date_second <int>, date_hour12 <int>, date_am.pm <int>, date_wday <int>, #> #   date_mday <int>, date_qday <int>, date_yday <int>, date_mweek <int>, #> #   date_week <int>, date_week2 <int>, date_week3 <int>, date_week4 <int>, #> #   date_mday7 <int>, date_month.lbl_01 <dbl>, date_month.lbl_02 <dbl>, #> #   date_month.lbl_03 <dbl>, date_month.lbl_04 <dbl>, …"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"model-1---auto-arima","dir":"Articles","previous_headings":"Modeling","what":"Model 1 - Auto ARIMA","title":"Getting Started with Modeltime Ensemble","text":"First, ’ll make ARIMA model using Auto ARIMA.","code":"model_spec_arima <- arima_reg() %>%     set_engine(\"auto_arima\")  wflw_fit_arima <- workflow() %>%     add_model(model_spec_arima) %>%     add_recipe(recipe_spec %>% step_rm(all_predictors(), -date)) %>%     fit(training(splits))"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"model-2---prophet","dir":"Articles","previous_headings":"Modeling","what":"Model 2 - Prophet","title":"Getting Started with Modeltime Ensemble","text":"Next, ’ll make Prophet Model.","code":"model_spec_prophet <- prophet_reg() %>%     set_engine(\"prophet\")  wflw_fit_prophet <- workflow() %>%     add_model(model_spec_prophet) %>%     add_recipe(recipe_spec %>% step_rm(all_predictors(), -date)) %>%     fit(training(splits))"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"model-3---elastic-net","dir":"Articles","previous_headings":"Modeling","what":"Model 3 - Elastic Net","title":"Getting Started with Modeltime Ensemble","text":"Third, ’ll make Elastic Net Model using glmnet.","code":"model_spec_glmnet <- linear_reg(     mixture = 0.9,     penalty = 4.36e-6 ) %>%     set_engine(\"glmnet\")  wflw_fit_glmnet <- workflow() %>%     add_model(model_spec_glmnet) %>%     add_recipe(recipe_spec %>% step_rm(date)) %>%     fit(training(splits))"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"modeltime-workflow-for-ensemble-forecasting","dir":"Articles","previous_headings":"","what":"Modeltime Workflow for Ensemble Forecasting","title":"Getting Started with Modeltime Ensemble","text":"models created, can can create Ensemble Average Model using simple Mean Average.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"step-1---create-a-modeltime-table","dir":"Articles","previous_headings":"Modeltime Workflow for Ensemble Forecasting","what":"Step 1 - Create a Modeltime Table","title":"Getting Started with Modeltime Ensemble","text":"Create Modeltime Table using modeltime package.","code":"m750_models <- modeltime_table(     wflw_fit_arima,     wflw_fit_prophet,     wflw_fit_glmnet )  m750_models #> # Modeltime Table #> # A tibble: 3 × 3 #>   .model_id .model     .model_desc             #>       <int> <list>     <chr>                   #> 1         1 <workflow> ARIMA(0,1,1)(0,1,1)[12] #> 2         2 <workflow> PROPHET                 #> 3         3 <workflow> GLMNET"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"step-2---make-an-ensemble","dir":"Articles","previous_headings":"Modeltime Workflow for Ensemble Forecasting","what":"Step 2 - Make an Ensemble","title":"Getting Started with Modeltime Ensemble","text":"use ensemble_average() turn Modeltime Table Modeltime Ensemble. fitted ensemble specification containing ingredients forecast future data refitted data sets using 3 submodels.","code":"ensemble_fit <- m750_models %>%     ensemble_average(type = \"mean\")  ensemble_fit #> ── Modeltime Ensemble ─────────────────────────────────────────── #> Ensemble of 3 Models (MEAN)  #>  #> # Modeltime Table #> # A tibble: 3 × 3 #>   .model_id .model     .model_desc             #>       <int> <list>     <chr>                   #> 1         1 <workflow> ARIMA(0,1,1)(0,1,1)[12] #> 2         2 <workflow> PROPHET                 #> 3         3 <workflow> GLMNET"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"step-3---forecast-the-test-data","dir":"Articles","previous_headings":"Modeltime Workflow for Ensemble Forecasting","what":"Step 3 - Forecast! (the Test Data)","title":"Getting Started with Modeltime Ensemble","text":"forecast, just follow Modeltime Workflow.","code":"# Calibration calibration_tbl <- modeltime_table(     ensemble_fit ) %>%     modeltime_calibrate(testing(m750_splits))  # Forecast vs Test Set calibration_tbl %>%     modeltime_forecast(         new_data    = testing(m750_splits),         actual_data = m750     ) %>%     plot_modeltime_forecast(.interactive = interactive)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"step-4---refit-on-full-data-forecast-future","dir":"Articles","previous_headings":"Modeltime Workflow for Ensemble Forecasting","what":"Step 4 - Refit on Full Data & Forecast Future","title":"Getting Started with Modeltime Ensemble","text":"satisfied ensemble model, can modeltime_refit() full data set forecast forward gaining confidence intervals process.  short tutorial simplest type forecasting, ’s lot learn.","code":"refit_tbl <- calibration_tbl %>%     modeltime_refit(m750)  refit_tbl %>%     modeltime_forecast(         h = \"2 years\",         actual_data = m750     ) %>%     plot_modeltime_forecast(.interactive = interactive)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"take-the-high-performance-forecasting-course","dir":"Articles","previous_headings":"Modeltime Workflow for Ensemble Forecasting","what":"Take the High-Performance Forecasting Course","title":"Getting Started with Modeltime Ensemble","text":"Become forecasting expert organization  High-Performance Time Series Course","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"time-series-is-changing","dir":"Articles","previous_headings":"Modeltime Workflow for Ensemble Forecasting > Take the High-Performance Forecasting Course","what":"Time Series is Changing","title":"Getting Started with Modeltime Ensemble","text":"Time series changing. Businesses now need 10,000+ time series forecasts every day. call High-Performance Time Series Forecasting System (HPTSF) - Accurate, Robust, Scalable Forecasting. High-Performance Forecasting Systems save companies improving accuracy scalability. Imagine happen career can provide organization “High-Performance Time Series Forecasting System” (HPTSF System).","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/getting-started-with-modeltime-ensemble.html","id":"how-to-learn-high-performance-time-series-forecasting","dir":"Articles","previous_headings":"Modeltime Workflow for Ensemble Forecasting > Take the High-Performance Forecasting Course","what":"How to Learn High-Performance Time Series Forecasting","title":"Getting Started with Modeltime Ensemble","text":"teach build HPTFS System High-Performance Time Series Forecasting Course. learn: Time Series Machine Learning (cutting-edge) Modeltime - 30+ Models (Prophet, ARIMA, XGBoost, Random Forest, & many ) Deep Learning GluonTS (Competition Winners) Time Series Preprocessing, Noise Reduction, & Anomaly Detection Feature engineering using lagged variables & external regressors Hyperparameter Tuning Time series cross-validation Ensembling Multiple Machine Learning & Univariate Modeling Techniques (Competition Winner) Scalable Forecasting - Forecast 1000+ time series parallel . Become Time Series Expert organization. Take High-Performance Time Series Forecasting Course","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"what-is-nested-forecasting","dir":"Articles","previous_headings":"","what":"What is Nested Forecasting?","title":"Iterative Forecasting with Nested Ensembles","text":"core idea nested forecasting convert dataset containing many time series groups nested data set, fit many models nested datasets. result iterative forecasting process generates Nested Modeltime Tables forecast attributes needed make decisions.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"what-is-nested-ensembling","dir":"Articles","previous_headings":"","what":"What is Nested Ensembling?","title":"Iterative Forecasting with Nested Ensembles","text":"Nested ensembling applies concept ensembling, generally averaging many individual models (called submodels) produce stable model sometimes improves best individual model. can apply ensembling techniques iterative nested forecasting. tutorial, show perform: Average Ensembles using ensemble_nested_average(). simplest models. Weighted Ensembles using ensemble_nested_weighted(). allow user provide “loadings” distribute weighting top models, can sometimes improve simple average ensembles. Let’s go!","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"nested-ensemble-tutorial","dir":"Articles","previous_headings":"","what":"Nested Ensemble Tutorial","title":"Iterative Forecasting with Nested Ensembles","text":"’ll showcase nested ensembling iterative forecasting short tutorial.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"libraries","dir":"Articles","previous_headings":"Nested Ensemble Tutorial","what":"Libraries","title":"Iterative Forecasting with Nested Ensembles","text":"Load following libraries.","code":"library(tidymodels) library(modeltime) library(modeltime.ensemble) library(dplyr) library(timetk) library(gt)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"data","dir":"Articles","previous_headings":"Nested Ensemble Tutorial","what":"Data","title":"Iterative Forecasting with Nested Ensembles","text":"Read Walmart Sales Weekly data (comes timetk). can get quick visual two time series forecast.","code":"data_tbl <- walmart_sales_weekly %>%     select(id, date = Date, value = Weekly_Sales) %>%     filter(id %in% c(\"1_1\", \"1_3\"))  data_tbl #> # A tibble: 286 × 3 #>    id    date        value #>    <fct> <date>      <dbl> #>  1 1_1   2010-02-05 24924. #>  2 1_1   2010-02-12 46039. #>  3 1_1   2010-02-19 41596. #>  4 1_1   2010-02-26 19404. #>  5 1_1   2010-03-05 21828. #>  6 1_1   2010-03-12 21043. #>  7 1_1   2010-03-19 22137. #>  8 1_1   2010-03-26 26229. #>  9 1_1   2010-04-02 57258. #> 10 1_1   2010-04-09 42961. #> # ℹ 276 more rows data_tbl %>%   group_by(id) %>%   plot_time_series(date, value, .facet_ncol = 1, .interactive = FALSE)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"prepare-the-data-in-nested-format","dir":"Articles","previous_headings":"Nested Ensemble Tutorial","what":"Prepare the Data in Nested Format","title":"Iterative Forecasting with Nested Ensembles","text":"critical stage “Nested Forecasting” data preparation, making sure input nested forecasting workflow appropriate structure. ’ve included several functions help involve bit forethought can broken 3 steps: Extending times series: far future need predict time series? See extend_timeseries(). Nesting grouping variable: create nested structure. ’ll identify ID column separates time series, number timestamps include “.future_data” optionally “.actual_data”. Typically, ’ll select .length_future extension previous step. See nest_timeseries(). Train/Test Set Splitting: Finally, ’ll take .actual_data convert train/test splits can used accuracy confidence interval estimation. See split_nested_timeseries(). 3-steps action:","code":"nested_data_tbl <- data_tbl %>%     # Step 1: Extend     extend_timeseries(         .id_var        = id,         .date_var      = date,         .length_future = 52     ) %>%     # Step 2: Nest     nest_timeseries(         .id_var        = id,         .length_future = 52,         .length_actual = 52*2     ) %>%     # Step 3: Split Train/Test     split_nested_timeseries(         .length_test = 52     )  nested_data_tbl #> # A tibble: 2 × 4 #>   id    .actual_data       .future_data      .splits         #>   <fct> <list>             <list>            <list>          #> 1 1_1   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> #> 2 1_3   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]>"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"nested-modeltime-workflow","dir":"Articles","previous_headings":"Nested Ensemble Tutorial","what":"Nested Modeltime Workflow","title":"Iterative Forecasting with Nested Ensembles","text":"Next, move Nested Modeltime Workflow now nested data created. Nested Modeltime Workflow includes 3 steps: Modeling Fitting: training stage fit training data. test forecast generated step. Create tidymodels workflows. modeltime_nested_fit(): Used fit submodels training data. ensemble_nested_average() ensemble_nested_weighted(): Used make ensembles submodels. Model Evaluation Selection: review model performance select best model minimizing maximizing error metric. See modeltime_nested_select_best(). Model Refitting: final fitting stage fit actual data. future forecast generated step. See modeltime_nested_refit().","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"step-1a-create-tidymodels-workflows","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow","what":"Step 1A: Create Tidymodels Workflows","title":"Iterative Forecasting with Nested Ensembles","text":"First, create tidymodels workflows various models intend create.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"prophet","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow > Step 1A: Create Tidymodels Workflows","what":"Prophet","title":"Iterative Forecasting with Nested Ensembles","text":"common modeling method prophet, can created using prophet_reg(). ’ll create workflow. Note use extract_nested_train_split(nested_data_tbl) help us build preprocessing features.","code":"rec_prophet <- recipe(value ~ date, extract_nested_train_split(nested_data_tbl))   wflw_prophet <- workflow() %>%     add_model(         prophet_reg(\"regression\", seasonality_yearly = TRUE) %>%              set_engine(\"prophet\")     ) %>%     add_recipe(rec_prophet)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"xgboost","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow > Step 1A: Create Tidymodels Workflows","what":"XGBoost","title":"Iterative Forecasting with Nested Ensembles","text":"Next, can use machine learning method can get good results: XGBoost. add extra features recipe feature engineering step generate features tend get better modeling results. Note use extract_nested_train_split(nested_data_tbl) help us build preprocessing features.","code":"rec_xgb <- recipe(value ~ ., extract_nested_train_split(nested_data_tbl)) %>%     step_timeseries_signature(date) %>%     step_rm(date) %>%     step_zv(all_predictors()) %>%     step_dummy(all_nominal_predictors(), one_hot = TRUE)  wflw_xgb <- workflow() %>%     add_model(boost_tree(\"regression\") %>% set_engine(\"xgboost\")) %>%     add_recipe(rec_xgb)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"step-1b-nested-modeltime-tables","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow","what":"Step 1B: Nested Modeltime Tables","title":"Iterative Forecasting with Nested Ensembles","text":"couple modeling workflows hand, now ready test time series. start using modeltime_nested_fit() function, iteratively fits model nested time series train/test “.splits” column. adds new column .modeltime_tables data sets created several logged attributes part “Nested Modeltime Table”. also can see models trained “.splits” none models errors.","code":"nested_modeltime_tbl <- modeltime_nested_fit(   # Nested data    nested_data = nested_data_tbl,      # Add workflows   wflw_prophet,   wflw_xgb ) #> Fitting models on training data... ■■■■■■■■■■■■■■■■                  50% | ETA:… #> Fitting models on training data... ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:… nested_modeltime_tbl #> # Nested Modeltime Table #> #> Trained on: .splits | Model Errors: [0] #> # A tibble: 2 × 5 #>   id    .actual_data       .future_data      .splits         .modeltime_tables  #>   <fct> <list>             <list>            <list>          <list>             #> 1 1_1   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> <mdl_tm_t [2 × 5]> #> 2 1_3   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> <mdl_tm_t [2 × 5]>"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"accuracy-check","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow > Step 1B: Nested Modeltime Tables","what":"Accuracy Check","title":"Iterative Forecasting with Nested Ensembles","text":"kind advanced, accuracy functions (table_modeltime_accuracy(.interactive = FALSE)) produce static gt table, can make function highlight rows group. now can see models winners, performing best group lowest RMSE (root mean squared error).","code":"tab_style_by_group <- function(object, ..., style) {      subset_log <- object[[\"_boxhead\"]][[\"type\"]]==\"row_group\"   grp_col    <- object[[\"_boxhead\"]][[\"var\"]][subset_log] %>% rlang::sym()      object %>%     tab_style(       style = style,       locations = cells_body(         rows = .[[\"_data\"]] %>%           tibble::rowid_to_column(\"rowid\") %>%           group_by(!!grp_col) %>%           filter(...) %>%           ungroup() %>%           pull(rowid)       )     ) } nested_modeltime_tbl %>%    extract_nested_test_accuracy() %>%   group_by(id) %>%   table_modeltime_accuracy(.interactive = FALSE) %>%   tab_style_by_group(     rmse == min(rmse),     style = cell_fill(color = \"lightblue\")   )"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"step-1c-make-ensembles","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow","what":"Step 1C: Make Ensembles","title":"Iterative Forecasting with Nested Ensembles","text":"Now ’ve fitted submodels, goal improve submodels leveraging ensembles.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"average-ensemble","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow > Step 1C: Make Ensembles","what":"Average Ensemble","title":"Iterative Forecasting with Nested Ensembles","text":"’ll give go average ensemble using simple mean ensemble_nested_average() function. select type = \"mean\" simple average (another option median ensemble, better models large spikes). can check accuracy . time Ensemble (MEAN) outperforms prophet xgboost submodels.","code":"nested_ensemble_1_tbl <- nested_modeltime_tbl %>%     ensemble_nested_average(         type           = \"mean\",          keep_submodels = TRUE     )  nested_ensemble_1_tbl #> # Nested Modeltime Table #>   # A tibble: 2 × 5 #>   id    .actual_data       .future_data      .splits         .modeltime_tables  #>   <fct> <list>             <list>            <list>          <list>             #> 1 1_1   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> <mdl_tm_t [3 × 5]> #> 2 1_3   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> <mdl_tm_t [3 × 5]> nested_ensemble_1_tbl %>%    extract_nested_test_accuracy() %>%   group_by(id) %>%   table_modeltime_accuracy(.interactive = FALSE) %>%   tab_style_by_group(     rmse == min(rmse),     style = cell_fill(color = \"lightblue\")   )"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"weighted-ensemble","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow > Step 1C: Make Ensembles","what":"Weighted Ensemble","title":"Iterative Forecasting with Nested Ensembles","text":"Next, can give go weighted ensemble ensemble_nested_weighted() function. key points arguments: loadings: parameter allows us weight models differently. Providing c(2,1) places 2--1 weighting two submodels. metric: parameter determined accuracy table. default use “rmse” column. loadings applied best (lowest) “rmse” first. best model 2/3 (66% weight) loading second best 1/3 (33% weight). model_ids: filtering mechanism help us isolate model ID’s want include submodels. want exclude Model ID 3, Ensemble Average (MEAN) model. control: uses control_nested_fit() control aspects fitting process like running Parallel vs Sequential outputting verbose provide additional information fitting process. Next, let’s check accuracy new ensemble. Weighted Ensemble improved 1_1 time series, 1_3 time series.","code":"nested_ensemble_2_tbl <- nested_ensemble_1_tbl %>%     ensemble_nested_weighted(         loadings        = c(2,1),           metric          = \"rmse\",         model_ids       = c(1,2),          control         = control_nested_fit(allow_par = FALSE, verbose = TRUE)     ) #> ℹ [1/2] Starting Modeltime Table: ID 1_1... #> ✔ Model 4 Passed ENSEMBLE WEIGHTED. #> ✔ [1/2] Finished Modeltime Table: ID 1_1 #> ℹ [2/2] Starting Modeltime Table: ID 1_3... #> ✔ Model 4 Passed ENSEMBLE WEIGHTED. #> ✔ [2/2] Finished Modeltime Table: ID 1_3 #> Finished in: 1.776939 secs. nested_ensemble_2_tbl #> # Nested Modeltime Table #> #> Trained on: .splits | Model Errors: [0] #> # A tibble: 2 × 5 #>   id    .actual_data       .future_data      .splits         .modeltime_tables  #>   <fct> <list>             <list>            <list>          <list>             #> 1 1_1   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> <mdl_tm_t [4 × 5]> #> 2 1_3   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> <mdl_tm_t [4 × 5]> nested_ensemble_2_tbl %>%    extract_nested_test_accuracy() %>%   group_by(id) %>%   table_modeltime_accuracy(.interactive = FALSE) %>%   tab_style_by_group(     rmse == min(rmse),     style = cell_fill(color = \"lightblue\")   )"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"step-2-select-best","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow","what":"Step 2: Select Best","title":"Iterative Forecasting with Nested Ensembles","text":"Using accuracy data, can pick metric select best model based metric. available metrics default_forecast_accuracy_metric_set(). Make sure select minimize based metric. filter_test_forecasts parameter tells function filter logged test forecasts just best.","code":"best_nested_modeltime_tbl <- nested_ensemble_2_tbl %>%     modeltime_nested_select_best(       metric                = \"rmse\",        minimize              = TRUE,        filter_test_forecasts = TRUE     )"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"extract-nested-best-model-report","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow > Step 2: Select Best","what":"Extract Nested Best Model Report","title":"Iterative Forecasting with Nested Ensembles","text":"best model selections can accessed extract_nested_best_model_report().","code":"best_nested_modeltime_tbl %>%   extract_nested_best_model_report() %>%   table_modeltime_accuracy(.interactive = FALSE)"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"extract-nested-best-test-forecasts","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow > Step 2: Select Best","what":"Extract Nested Best Test Forecasts","title":"Iterative Forecasting with Nested Ensembles","text":"’ve selected best models, can easily visualize best forecasts time series. Note nested test forecast logs modified isolate best models.","code":"best_nested_modeltime_tbl %>%   extract_nested_test_forecast() %>%   group_by(id) %>%   plot_modeltime_forecast(     .facet_ncol  = 1,     .interactive = FALSE   )"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"step-3-refitting-and-future-forecast","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow","what":"Step 3: Refitting and Future Forecast","title":"Iterative Forecasting with Nested Ensembles","text":"best models hand, can make future forecasts refitting models full dataset. best models selected, best models refit. best models selected, models refit. ’ve selected best models, move forward refitting future forecast logging using modeltime_nested_refit() function. can see nested modeltime table appears , now trained .actual_data.","code":"nested_modeltime_refit_tbl <- best_nested_modeltime_tbl %>%     modeltime_nested_refit(         control = control_nested_refit(verbose = TRUE)     ) #> ℹ [1/2] Starting Modeltime Table: ID 1_1... #> ✔ Model 4 Passed ENSEMBLE (WEIGHTED): 2 MODELS. #> ✔ [1/2] Finished Modeltime Table: ID 1_1 #> ℹ [2/2] Starting Modeltime Table: ID 1_3... #> ✔ Model 3 Passed ENSEMBLE (MEAN): 2 MODELS. #> ✔ [2/2] Finished Modeltime Table: ID 1_3 #> Finished in: 1.211836 secs. nested_modeltime_refit_tbl #> # Nested Modeltime Table #> #> Trained on: .actual_data | Model Errors: [0] #> # A tibble: 2 × 5 #>   id    .actual_data       .future_data      .splits         .modeltime_tables  #>   <fct> <list>             <list>            <list>          <list>             #> 1 1_1   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> <mdl_tm_t [1 × 5]> #> 2 1_3   <tibble [104 × 2]> <tibble [52 × 2]> <split [52|52]> <mdl_tm_t [1 × 5]>"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"extract-nested-future-forecast","dir":"Articles","previous_headings":"Nested Ensemble Tutorial > Nested Modeltime Workflow > Step 3: Refitting and Future Forecast","what":"Extract Nested Future Forecast","title":"Iterative Forecasting with Nested Ensembles","text":"refitting process completes, can now access future forecast, logged.","code":"nested_modeltime_refit_tbl %>%   extract_nested_future_forecast() %>%   group_by(id) %>%   plot_modeltime_forecast(     .interactive = FALSE,     .facet_ncol  = 2   )"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Iterative Forecasting with Nested Ensembles","text":"Nested ensembling powerful technique can improve forecasting accuracy. , just small portion can done take forecasting next level… want become forecasting expert organization, take read !","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"take-the-high-performance-forecasting-course","dir":"Articles","previous_headings":"Summary","what":"Take the High-Performance Forecasting Course","title":"Iterative Forecasting with Nested Ensembles","text":"Become forecasting expert organization  High-Performance Time Series Course","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"time-series-is-changing","dir":"Articles","previous_headings":"Summary > Take the High-Performance Forecasting Course","what":"Time Series is Changing","title":"Iterative Forecasting with Nested Ensembles","text":"Time series changing. Businesses now need 10,000+ time series forecasts every day. call High-Performance Time Series Forecasting System (HPTSF) - Accurate, Robust, Scalable Forecasting. High-Performance Forecasting Systems save companies improving accuracy scalability. Imagine happen career can provide organization “High-Performance Time Series Forecasting System” (HPTSF System).","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/nested-ensembles.html","id":"how-to-learn-high-performance-time-series-forecasting","dir":"Articles","previous_headings":"Summary > Take the High-Performance Forecasting Course","what":"How to Learn High-Performance Time Series Forecasting","title":"Iterative Forecasting with Nested Ensembles","text":"teach build HPTFS System High-Performance Time Series Forecasting Course. learn: Time Series Machine Learning (cutting-edge) Modeltime - 30+ Models (Prophet, ARIMA, XGBoost, Random Forest, & many ) Deep Learning GluonTS (Competition Winners) Time Series Preprocessing, Noise Reduction, & Anomaly Detection Feature engineering using lagged variables & external regressors Hyperparameter Tuning Time series cross-validation Ensembling Multiple Machine Learning & Univariate Modeling Techniques (Competition Winner) Scalable Forecasting - Forecast 1000+ time series parallel .  Become Time Series Expert organization.   Take High-Performance Time Series Forecasting Course","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/recursive-ensembles.html","id":"what-is-a-recursive-model","dir":"Articles","previous_headings":"","what":"What is a Recursive Model?","title":"Autoregressive Forecasting (Recursive Ensembles)","text":"recursive model uses predictions generate new values independent features. features typically lags used autoregressive models.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/recursive-ensembles.html","id":"why-is-recursive-needed-for-autoregressive-models","dir":"Articles","previous_headings":"","what":"Why is Recursive needed for Autoregressive Models?","title":"Autoregressive Forecasting (Recursive Ensembles)","text":"’s important understand recursive model needed using lagged features Lag Size < Forecast Horizon. lag length less forecast horizon, problem exists missing values (NA) generated future data. solution recursive() implements iteratively fill missing values values generated predictions. technique can used : Single ensemble recursive predictions - Effectively turning ensemble model Autoregressive (AR) model Panel ensemble recursive predictions - many situations need forecast one time series. can batch-process 1 model processing time series groups panels. technique can extended recursive forecasting scalable models (1 model predicts many time series). ’s example panel forecast uses recursive ensemble Elastic Net XGBoost models.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/recursive-ensembles.html","id":"single-ensemble-recursive-example","dir":"Articles","previous_headings":"","what":"Single Ensemble Recursive Example","title":"Autoregressive Forecasting (Recursive Ensembles)","text":"Use single ensembles forecast single time series First, need load necessary libraries: Next, select forecast horizon 24 days extend data frame function future_frame(). create future dataset, can distinguish values NA. next step create Transformer Function create lagged variables model use. Notice create lags forecast horizon. also include rolling features number “engineered features” based lags. divide data set training dataset future dataset: Next, going create two models join ensemble. first model Linear Regression model second model MARS model real scenario, typically pre-selection work analyze models keep better performance make ensemble. next step create ensemble type mean (predictions two models averaged) right use recursive() function create recursive model. recursive() function tells ensemble use recursion prediction process recursive model uses Transformer Function train_tail generate transformations (e.g. lags) prediction process can consult information function typing console ?modeltime::recursive. Next, add recursive ensemble modeltime table, organizes one models prior forecasting. Finally, predict dataset visualize predictions:","code":"library(modeltime.ensemble) library(modeltime) library(tidymodels) library(glmnet) library(xgboost) library(dplyr) library(lubridate) library(timetk) FORECAST_HORIZON <- 24  m750_extended <- m750 %>%     group_by(id) %>%     future_frame(         .length_out = FORECAST_HORIZON,         .bind_data  = TRUE     ) %>%     ungroup() lag_transformer <- function(data){     data %>%         tk_augment_lags(value, .lags = 1:FORECAST_HORIZON) }  # Data Preparation m750_lagged <- m750_extended %>% lag_transformer() m750_lagged #> # A tibble: 330 × 27 #>    id    date       value value_lag1 value_lag2 value_lag3 value_lag4 value_lag5 #>    <fct> <date>     <dbl>      <dbl>      <dbl>      <dbl>      <dbl>      <dbl> #>  1 M750  1990-01-01  6370         NA         NA         NA         NA         NA #>  2 M750  1990-02-01  6430       6370         NA         NA         NA         NA #>  3 M750  1990-03-01  6520       6430       6370         NA         NA         NA #>  4 M750  1990-04-01  6580       6520       6430       6370         NA         NA #>  5 M750  1990-05-01  6620       6580       6520       6430       6370         NA #>  6 M750  1990-06-01  6690       6620       6580       6520       6430       6370 #>  7 M750  1990-07-01  6000       6690       6620       6580       6520       6430 #>  8 M750  1990-08-01  5450       6000       6690       6620       6580       6520 #>  9 M750  1990-09-01  6480       5450       6000       6690       6620       6580 #> 10 M750  1990-10-01  6820       6480       5450       6000       6690       6620 #> # ℹ 320 more rows #> # ℹ 19 more variables: value_lag6 <dbl>, value_lag7 <dbl>, value_lag8 <dbl>, #> #   value_lag9 <dbl>, value_lag10 <dbl>, value_lag11 <dbl>, value_lag12 <dbl>, #> #   value_lag13 <dbl>, value_lag14 <dbl>, value_lag15 <dbl>, value_lag16 <dbl>, #> #   value_lag17 <dbl>, value_lag18 <dbl>, value_lag19 <dbl>, value_lag20 <dbl>, #> #   value_lag21 <dbl>, value_lag22 <dbl>, value_lag23 <dbl>, value_lag24 <dbl> train_data <- m750_lagged %>%     filter(!is.na(value)) %>%     tidyr::drop_na()  future_data <- m750_lagged %>%     filter(is.na(value)) model_fit_lm <- linear_reg() %>%     set_engine(\"lm\") %>%     fit(value ~ ., data = train_data %>% select(-id))  model_fit_mars <- mars(\"regression\") %>%     set_engine(\"earth\", endspan = 24) %>%     fit(value ~ ., data = train_data %>% select(-id)) recursive_ensemble <- modeltime_table(     model_fit_lm,     model_fit_mars ) %>%     ensemble_average(type = \"mean\") %>%     recursive(         transform  = lag_transformer,         train_tail = tail(train_data, FORECAST_HORIZON)     )  recursive_ensemble #> Recursive [modeltime ensemble] #>  #> ── Modeltime Ensemble ─────────────────────────────────────────── #> Ensemble of 2 Models (MEAN)  #>  #> # Modeltime Table #> # A tibble: 2 × 3 #>   .model_id .model   .model_desc #>       <int> <list>   <chr>       #> 1         1 <fit[+]> LM          #> 2         2 <fit[+]> EARTH model_tbl <- modeltime_table(     recursive_ensemble )  model_tbl #> # Modeltime Table #> # A tibble: 1 × 3 #>   .model_id .model .model_desc                         #>       <int> <list> <chr>                               #> 1         1 <>     RECURSIVE ENSEMBLE (MEAN): 2 MODELS model_tbl %>%     modeltime_forecast(         new_data    = future_data,         actual_data = m750     ) %>%     plot_modeltime_forecast(         .interactive        = FALSE,         .conf_interval_show = FALSE,     )"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/recursive-ensembles.html","id":"panel-ensemble-recursive-example","dir":"Articles","previous_headings":"","what":"Panel Ensemble Recursive Example","title":"Autoregressive Forecasting (Recursive Ensembles)","text":"Use panel ensembles batch forecast multimple time series complex extension previous example forecasting multiple time series batches. ’ll showcase Weighted Ensemble XGBoost GLMNET. First, select forecast horizon 24 days extend data frame function future_frame(). create future dataset, can distinguish values NA. create Transformer Function charge generating lags time series forecasting horizon. Note time use grouped lags generate lags group. important multiple time series. Make sure ungroup lagging process. , apply function divide data training future set: split training data future data. Next, going create two models join ensemble. first model Elastic Net (GLMNET) model: elastic net applies improved version linear regression applies penalty lagged regressors preventing bad lags dominating results. can show improvement versus standard Linear Regression. second model XGBOOST model: xgboost model tree-based algorithm different models vs linear model. ’s much better non-linear data (e.g. seasonality). next step create ensemble. ’ll use Weighted Ensemble (ensemble_weighted()) 60/40 loading. Right use recursive() function create recursive model. Unlike previous example: pass recursive function argument id specifying ID’s time series group use panel_tail() function create train_tail group. Next, add recursive ensemble modeltime table, organizes one models prior forecasting. Finally, forecast dataset visualize forecast.","code":"FORECAST_HORIZON <- 24  m4_extended <- m4_monthly %>%     group_by(id) %>%     future_frame(         .length_out = FORECAST_HORIZON,         .bind_data  = TRUE     ) %>%     ungroup() lag_transformer_grouped <- function(data){     data %>%         group_by(id) %>%         tk_augment_lags(value, .lags = 1:FORECAST_HORIZON) %>%         ungroup() } m4_lags <- m4_extended %>%     lag_transformer_grouped()  m4_lags #> # A tibble: 1,670 × 27 #>    id    date       value value_lag1 value_lag2 value_lag3 value_lag4 value_lag5 #>    <fct> <date>     <dbl>      <dbl>      <dbl>      <dbl>      <dbl>      <dbl> #>  1 M1    1976-06-01  8000         NA         NA         NA         NA         NA #>  2 M1    1976-07-01  8350       8000         NA         NA         NA         NA #>  3 M1    1976-08-01  8570       8350       8000         NA         NA         NA #>  4 M1    1976-09-01  7700       8570       8350       8000         NA         NA #>  5 M1    1976-10-01  7080       7700       8570       8350       8000         NA #>  6 M1    1976-11-01  6520       7080       7700       8570       8350       8000 #>  7 M1    1976-12-01  6070       6520       7080       7700       8570       8350 #>  8 M1    1977-01-01  6650       6070       6520       7080       7700       8570 #>  9 M1    1977-02-01  6830       6650       6070       6520       7080       7700 #> 10 M1    1977-03-01  5710       6830       6650       6070       6520       7080 #> # ℹ 1,660 more rows #> # ℹ 19 more variables: value_lag6 <dbl>, value_lag7 <dbl>, value_lag8 <dbl>, #> #   value_lag9 <dbl>, value_lag10 <dbl>, value_lag11 <dbl>, value_lag12 <dbl>, #> #   value_lag13 <dbl>, value_lag14 <dbl>, value_lag15 <dbl>, value_lag16 <dbl>, #> #   value_lag17 <dbl>, value_lag18 <dbl>, value_lag19 <dbl>, value_lag20 <dbl>, #> #   value_lag21 <dbl>, value_lag22 <dbl>, value_lag23 <dbl>, value_lag24 <dbl> train_data <- m4_lags %>%     tidyr::drop_na()  future_data <- m4_lags %>%     filter(is.na(value)) model_fit_glmnet <- linear_reg(penalty = 1) %>%     set_engine(\"glmnet\") %>%     fit(value ~ ., data = train_data)  model_fit_xgboost <- boost_tree(\"regression\", learn_rate = 0.35) %>%     set_engine(\"xgboost\") %>%     fit(value ~ ., data = train_data) recursive_ensemble_panel <- modeltime_table(     model_fit_glmnet,     model_fit_xgboost ) %>%     ensemble_weighted(loadings = c(4, 6)) %>%     recursive(         transform  = lag_transformer_grouped,         train_tail = panel_tail(train_data, id, FORECAST_HORIZON),         id         = \"id\"     )  recursive_ensemble_panel #> Recursive [modeltime ensemble] #>  #> ── Modeltime Ensemble ─────────────────────────────────────────── #> Ensemble of 2 Models (WEIGHTED)  #>  #> # Modeltime Table #> # A tibble: 2 × 4 #>   .model_id .model   .model_desc .loadings #>       <int> <list>   <chr>           <dbl> #> 1         1 <fit[+]> GLMNET            0.4 #> 2         2 <fit[+]> XGBOOST           0.6 model_tbl <- modeltime_table(     recursive_ensemble_panel )  model_tbl #> # Modeltime Table #> # A tibble: 1 × 3 #>   .model_id .model .model_desc                             #>       <int> <list> <chr>                                   #> 1         1 <>     RECURSIVE ENSEMBLE (WEIGHTED): 2 MODELS model_tbl %>%     modeltime_forecast(         new_data    = future_data,         actual_data = m4_lags,         keep_data   = TRUE     ) %>%     group_by(id) %>%     plot_modeltime_forecast(         .interactive        = FALSE,         .conf_interval_show = FALSE,         .facet_ncol         = 2     )"},{"path":"https://business-science.github.io/modeltime.ensemble/articles/recursive-ensembles.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Autoregressive Forecasting (Recursive Ensembles)","text":"Recursive modeling can applied ensembles. , just small portion everything can done…. want get details, read !","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/recursive-ensembles.html","id":"take-the-high-performance-forecasting-course","dir":"Articles","previous_headings":"Summary","what":"Take the High-Performance Forecasting Course","title":"Autoregressive Forecasting (Recursive Ensembles)","text":"Become forecasting expert organization  High-Performance Time Series Course","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/recursive-ensembles.html","id":"time-series-is-changing","dir":"Articles","previous_headings":"Summary > Take the High-Performance Forecasting Course","what":"Time Series is Changing","title":"Autoregressive Forecasting (Recursive Ensembles)","text":"Time series changing. Businesses now need 10,000+ time series forecasts every day. call High-Performance Time Series Forecasting System (HPTSF) - Accurate, Robust, Scalable Forecasting. High-Performance Forecasting Systems save companies improving accuracy scalability. Imagine happen career can provide organization “High-Performance Time Series Forecasting System” (HPTSF System).","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/articles/recursive-ensembles.html","id":"how-to-learn-high-performance-time-series-forecasting","dir":"Articles","previous_headings":"Summary > Take the High-Performance Forecasting Course","what":"How to Learn High-Performance Time Series Forecasting","title":"Autoregressive Forecasting (Recursive Ensembles)","text":"teach build HPTFS System High-Performance Time Series Forecasting Course. learn: Time Series Machine Learning (cutting-edge) Modeltime - 30+ Models (Prophet, ARIMA, XGBoost, Random Forest, & many ) Deep Learning GluonTS (Competition Winners) Time Series Preprocessing, Noise Reduction, & Anomaly Detection Feature engineering using lagged variables & external regressors Hyperparameter Tuning Time series cross-validation Ensembling Multiple Machine Learning & Univariate Modeling Techniques (Competition Winner) Scalable Forecasting - Forecast 1000+ time series parallel .  Become Time Series Expert organization.   Take High-Performance Time Series Forecasting Course","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matt Dancho. Author, maintainer. Business Science. Copyright holder.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Dancho M (2024). modeltime.ensemble: Ensemble Algorithms Time Series Forecasting Modeltime. R package version 1.0.3.9000, https://github.com/business-science/modeltime.ensemble, https://business-science.github.io/modeltime.ensemble/.","code":"@Manual{,   title = {modeltime.ensemble: Ensemble Algorithms for Time Series Forecasting with Modeltime},   author = {Matt Dancho},   year = {2024},   note = {R package version 1.0.3.9000, https://github.com/business-science/modeltime.ensemble},   url = {https://business-science.github.io/modeltime.ensemble/}, }"},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"modeltimeensemble-","dir":"","previous_headings":"","what":"Ensemble Algorithms for Time Series Forecasting with Modeltime","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"Ensemble Algorithms Time Series Forecasting Modeltime modeltime extension implements ensemble forecasting methods including model averaging, weighted averaging, stacking.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"Install CRAN version: , install development version:","code":"install.packages(\"modeltime.ensemble\") remotes::install_github(\"business-science/modeltime.ensemble\")"},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"Getting Started Modeltime: Learn basics forecasting Modeltime. Getting Started Modeltime Ensemble: Learn basics forecasting Modeltime ensemble models.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"make-your-first-ensemble-in-minutes","dir":"","previous_headings":"","what":"Make Your First Ensemble in Minutes","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"Load following libraries.","code":"library(tidymodels) library(modeltime) library(modeltime.ensemble) library(dplyr) library(timetk)"},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"step-1---create-a-modeltime-table","dir":"","previous_headings":"Make Your First Ensemble in Minutes","what":"Step 1 - Create a Modeltime Table","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"Create Modeltime Table using modeltime package.","code":"m750_models #> # Modeltime Table #> # A tibble: 3 × 3 #>   .model_id .model     .model_desc             #>       <int> <list>     <chr>                   #> 1         1 <workflow> ARIMA(0,1,1)(0,1,1)[12] #> 2         2 <workflow> PROPHET                 #> 3         3 <workflow> GLMNET"},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"step-2---make-a-modeltime-ensemble","dir":"","previous_headings":"Make Your First Ensemble in Minutes","what":"Step 2 - Make a Modeltime Ensemble","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"turn Modeltime Table Modeltime Ensemble.","code":"ensemble_fit <- m750_models %>%     ensemble_average(type = \"mean\")  ensemble_fit #> ── Modeltime Ensemble ─────────────────────────────────────────── #> Ensemble of 3 Models (MEAN) #>  #> # Modeltime Table #> # A tibble: 3 × 3 #>   .model_id .model     .model_desc             #>       <int> <list>     <chr>                   #> 1         1 <workflow> ARIMA(0,1,1)(0,1,1)[12] #> 2         2 <workflow> PROPHET                 #> 3         3 <workflow> GLMNET"},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"step-3---forecast","dir":"","previous_headings":"Make Your First Ensemble in Minutes","what":"Step 3 - Forecast!","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"forecast, just follow Modeltime Workflow.","code":"# Calibration calibration_tbl <- modeltime_table(     ensemble_fit ) %>%     modeltime_calibrate(testing(m750_splits), quiet = FALSE)  # Forecast vs Test Set calibration_tbl %>%     modeltime_forecast(         new_data    = testing(m750_splits),         actual_data = m750     ) %>%     plot_modeltime_forecast(.interactive = FALSE)"},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"meet-the-modeltime-ecosystem","dir":"","previous_headings":"","what":"Meet the modeltime ecosystem","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"Learn growing ecosystem forecasting packages modeltime ecosystem growing Modeltime part growing ecosystem Modeltime forecasting packages. Modeltime (Machine Learning) Modeltime H2O (AutoML) Modeltime GluonTS (Deep Learning) Modeltime Ensemble (Blending Forecasts) Modeltime Resample (Backtesting) Timetk (Feature Engineering, Data Wrangling, Time Series Visualization)","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"take-the-high-performance-forecasting-course","dir":"","previous_headings":"","what":"Take the High-Performance Forecasting Course","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"Become forecasting expert organization  High-Performance Time Series Course","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"time-series-is-changing","dir":"","previous_headings":"Take the High-Performance Forecasting Course","what":"Time Series is Changing","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"Time series changing. Businesses now need 10,000+ time series forecasts every day. call High-Performance Time Series Forecasting System (HPTSF) - Accurate, Robust, Scalable Forecasting. High-Performance Forecasting Systems save companies improving accuracy scalability. Imagine happen career can provide organization “High-Performance Time Series Forecasting System” (HPTSF System).","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/index.html","id":"how-to-learn-high-performance-time-series-forecasting","dir":"","previous_headings":"Take the High-Performance Forecasting Course","what":"How to Learn High-Performance Time Series Forecasting","title":"Ensemble Algorithms for Time Series Forecasting with Modeltime","text":"teach build HPTFS System High-Performance Time Series Forecasting Course. learn: Time Series Machine Learning (cutting-edge) Modeltime - 30+ Models (Prophet, ARIMA, XGBoost, Random Forest, & many ) Deep Learning GluonTS (Competition Winners) Time Series Preprocessing, Noise Reduction, & Anomaly Detection Feature engineering using lagged variables & external regressors Hyperparameter Tuning Time series cross-validation Ensembling Multiple Machine Learning & Univariate Modeling Techniques (Competition Winner) Scalable Forecasting - Forecast 1000+ time series parallel . Become Time Series Expert organization. Take High-Performance Time Series Forecasting Course","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_average.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates an Ensemble Model using Mean/Median Averaging — ensemble_average","title":"Creates an Ensemble Model using Mean/Median Averaging — ensemble_average","text":"Creates Ensemble Model using Mean/Median Averaging","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_average.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates an Ensemble Model using Mean/Median Averaging — ensemble_average","text":"","code":"ensemble_average(object, type = c(\"mean\", \"median\"))"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_average.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates an Ensemble Model using Mean/Median Averaging — ensemble_average","text":"object Modeltime Table type Specify type average (\"mean\" \"median\")","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_average.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates an Ensemble Model using Mean/Median Averaging — ensemble_average","text":"mdl_time_ensemble object.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_average.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates an Ensemble Model using Mean/Median Averaging — ensemble_average","text":"input ensemble_average() model always Modeltime Table, contains models ensemble. Averaging Methods average method uses un-weighted average using type either: \"mean\": Performs averaging using mean(x, na.rm = TRUE) aggregate underlying models forecast timestamp \"median\": Performs averaging using stats::median(x, na.rm = TRUE) aggregate underlying models forecast timestamp","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_average.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates an Ensemble Model using Mean/Median Averaging — ensemble_average","text":"","code":"# \\donttest{ library(tidymodels) #> ── Attaching packages ────────────────────────────────────── tidymodels 1.2.0 ── #> ✔ broom        1.0.6      ✔ recipes      1.0.10 #> ✔ dials        1.2.1      ✔ rsample      1.2.1  #> ✔ dplyr        1.1.4      ✔ tibble       3.2.1  #> ✔ ggplot2      3.5.1      ✔ tidyr        1.3.1  #> ✔ infer        1.0.7      ✔ tune         1.2.1  #> ✔ modeldata    1.3.0      ✔ workflows    1.1.4  #> ✔ parsnip      1.2.1      ✔ workflowsets 1.1.0  #> ✔ purrr        1.0.2      ✔ yardstick    1.3.1  #> ── Conflicts ───────────────────────────────────────── tidymodels_conflicts() ── #> ✖ purrr::discard() masks scales::discard() #> ✖ dplyr::filter()  masks stats::filter() #> ✖ dplyr::lag()     masks stats::lag() #> ✖ recipes::step()  masks stats::step() #> • Use suppressPackageStartupMessages() to eliminate package startup messages library(modeltime) library(modeltime.ensemble) library(dplyr) library(timetk)  # Make an ensemble from a Modeltime Table ensemble_fit <- m750_models %>%     ensemble_average(type = \"mean\")  ensemble_fit #> ── Modeltime Ensemble ─────────────────────────────────────────── #> Ensemble of 3 Models (MEAN)  #>  #> # Modeltime Table #> # A tibble: 3 × 3 #>   .model_id .model     .model_desc             #>       <int> <list>     <chr>                   #> 1         1 <workflow> ARIMA(0,1,1)(0,1,1)[12] #> 2         2 <workflow> PROPHET                 #> 3         3 <workflow> GLMNET                   # Forecast with the Ensemble modeltime_table(     ensemble_fit ) %>%     modeltime_forecast(         new_data    = testing(m750_splits),         actual_data = m750     ) %>%     plot_modeltime_forecast(         .interactive = FALSE,         .conf_interval_show = FALSE     ) #> Warning: There were 2 warnings in `dplyr::mutate()`. #> The first warning was: #> ℹ In argument: `.nested.col = purrr::map2(...)`. #> Caused by warning: #> ! There was 1 warning in `dplyr::mutate()`. #> ℹ In argument: `.nested.col = purrr::map2(...)`. #> Caused by warning: #> ! `keep_original_cols` was added to `step_dummy()` after this recipe was created. #> ℹ Regenerate your recipe to avoid this warning. #> ℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.  # }"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_model_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a Stacked Ensemble Model from a Model Spec — ensemble_model_spec","title":"Creates a Stacked Ensemble Model from a Model Spec — ensemble_model_spec","text":"2-stage stacking regressor follows: Stage 1: Sub-Model's Trained & Predicted using modeltime.resample::modeltime_fit_resamples(). Stage 2: Meta-learner (model_spec) trained --Sample Sub-Model Predictions using ensemble_model_spec().","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_model_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a Stacked Ensemble Model from a Model Spec — ensemble_model_spec","text":"","code":"ensemble_model_spec(   object,   model_spec,   kfolds = 5,   param_info = NULL,   grid = 6,   control = control_grid() )"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_model_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a Stacked Ensemble Model from a Model Spec — ensemble_model_spec","text":"object Modeltime Table. Used ensemble sub-models. model_spec model_spec object defining meta-learner stacking model specification used. Can either: non-tunable model_spec: Parameters specified optimized via tuning. tunable model_spec: Contains parameters identified tuning tune::tune() kfolds K-Fold Cross Validation tuning Meta-Learner. Controls number folds used meta-learner's cross-validation. Gets passed rsample::vfold_cv(). param_info dials::parameters() object NULL. none given, parameters set derived arguments. Passing argument can useful parameter ranges need customized. grid Grid specification grid size tuning Meta Learner. Gets passed tune::tune_grid(). control object used modify tuning process. Uses tune::control_grid() default. Use control_grid(verbose = TRUE) follow training process.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_model_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a Stacked Ensemble Model from a Model Spec — ensemble_model_spec","text":"mdl_time_ensemble object.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_model_spec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a Stacked Ensemble Model from a Model Spec — ensemble_model_spec","text":"Stacked Ensemble Process Start Modeltime Table define sub-models. Step 1: Use modeltime_fit_resamples() perform submodel resampling procedure. Step 2: Use ensemble_model_spec() define train meta-learner. goes inside Meta Learner? Meta-Learner Ensembling Process uses following basic steps: Make Cross-Validation Predictions. Cross validation predictions made sub-model modeltime_fit_resamples(). --sample sub-model predictions contained .resample_results used input meta-learner. Train Stacked Regressor (Meta-Learner). sub-model --sample cross validation predictions modeled using model_spec options: Tuning: model_spec include tuning parameters via tune::tune() meta-learner hypeparameter tuned using K-Fold Cross Validation. parameters grid can adjusted using kfolds, grid, param_info. -Tuning: model_spec include tuning parameters via tune::tune() meta-learner hypeparameter tuned model fitted sub-model predictions. Final Model Selection. tuned, final model selected based RMSE, retrained full set sample predictions. -tuned, fitted model Stage 2 used. Progress best way follow training process watch progress use control = control_grid(verbose = TRUE) see progress. Parallelize Portions process can parallelized. parallelize, set parallelization using tune via one backends doFuture. set control = control_grid(allow_par = TRUE)","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_model_spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a Stacked Ensemble Model from a Model Spec — ensemble_model_spec","text":"","code":"# \\donttest{ library(tidymodels) library(modeltime) library(modeltime.ensemble) library(dplyr) library(timetk)  # Step 1: Make resample predictions for submodels resamples_tscv <- training(m750_splits) %>%     time_series_cv(         assess  = \"2 years\",         initial = \"5 years\",         skip    = \"2 years\",         slice_limit = 1     ) #> Using date_var: date  submodel_predictions <- m750_models %>%     modeltime_fit_resamples(         resamples = resamples_tscv,         control   = control_resamples(verbose = TRUE)     ) #> ── Fitting Resamples ──────────────────────────────────────────── #>  #> • Model ID: 1 ARIMA(0,1,1)(0,1,1)[12] #> i Slice1: preprocessor 1/1 #> ! Slice1: preprocessor 1/1: #>   `keep_original_cols` was added to `step_dummy()` after this r... #>   ℹ Regenerate your recipe to avoid this warning. #> ✓ Slice1: preprocessor 1/1 #> i Slice1: preprocessor 1/1, model 1/1 #> frequency = 12 observations per 1 year #> ✓ Slice1: preprocessor 1/1, model 1/1 #> i Slice1: preprocessor 1/1, model 1/1 (extracts) #> i Slice1: preprocessor 1/1, model 1/1 (predictions) #> • Model ID: 2 PROPHET #> i Slice1: preprocessor 1/1 #> ! Slice1: preprocessor 1/1: #>   `keep_original_cols` was added to `step_dummy()` after this r... #>   ℹ Regenerate your recipe to avoid this warning. #> ✓ Slice1: preprocessor 1/1 #> i Slice1: preprocessor 1/1, model 1/1 #> Disabling weekly seasonality. Run prophet with weekly.seasonality=TRUE to override this. #> Disabling daily seasonality. Run prophet with daily.seasonality=TRUE to override this. #> ✓ Slice1: preprocessor 1/1, model 1/1 #> i Slice1: preprocessor 1/1, model 1/1 (extracts) #> i Slice1: preprocessor 1/1, model 1/1 (predictions) #> • Model ID: 3 GLMNET #> i Slice1: preprocessor 1/1 #> ! Slice1: preprocessor 1/1: #>   `keep_original_cols` was added to `step_dummy()` after this r... #>   ℹ Regenerate your recipe to avoid this warning. #> ✓ Slice1: preprocessor 1/1 #> i Slice1: preprocessor 1/1, model 1/1 #> ✓ Slice1: preprocessor 1/1, model 1/1 #> i Slice1: preprocessor 1/1, model 1/1 (extracts) #> i Slice1: preprocessor 1/1, model 1/1 (predictions) #> 4.036 sec elapsed #>   # Step 2: Metalearner ----  # * No Metalearner Tuning ensemble_fit_lm <- submodel_predictions %>%     ensemble_model_spec(         model_spec = linear_reg() %>% set_engine(\"lm\"),         control    = control_grid(verbose = TRUE)     ) #> ── Fitting Non-Tunable Model Specification ────────────────────── #> ℹ Fitting model spec to submodel cross-validation predictions. #>  #> ℹ Prediction Error Comparison: #> # A tibble: 4 × 3 #>   .model_id  rmse .model_desc             #>   <chr>     <dbl> <chr>                   #> 1 1          579. ARIMA(0,1,1)(0,1,1)[12] #> 2 2          381. PROPHET                 #> 3 3          558. GLMNET                  #> 4 ensemble   128. ENSEMBLE (MODEL SPEC)   #>  #> ── Final Model ────────────────────────────────────────────────── #>  #> ℹ Model Workflow: #> ══ Workflow [trained] ══════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: linear_reg() #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 0 Recipe Steps #>  #> ── Model ─────────────────────────────────────────────────────────────────────── #>  #> Call: #> stats::lm(formula = ..y ~ ., data = data) #>  #> Coefficients: #> (Intercept)  .model_id_1  .model_id_2  .model_id_3   #>  -2637.1730       0.5754      -0.1920       0.8551   #>  #>  #> 0.129 sec elapsed #>   ensemble_fit_lm #> ── Modeltime Ensemble ─────────────────────────────────────────── #> Ensemble of 3 Models (LM STACK)  #>  #> # Modeltime Table #> # A tibble: 3 × 3 #>   .model_id .model     .model_desc             #>       <int> <list>     <chr>                   #> 1         1 <workflow> ARIMA(0,1,1)(0,1,1)[12] #> 2         2 <workflow> PROPHET                 #> 3         3 <workflow> GLMNET                   # * With Metalearner Tuning ---- ensemble_fit_glmnet <- submodel_predictions %>%     ensemble_model_spec(         model_spec = linear_reg(             penalty = tune(),             mixture = tune()         ) %>%             set_engine(\"glmnet\"),         grid       = 2,         control    = control_grid(verbose = TRUE)     ) #> ── Tuning Model Specification ─────────────────────────────────── #> ℹ Performing 5-Fold Cross Validation. #>  #> i Fold1: preprocessor 1/1 #> ✓ Fold1: preprocessor 1/1 #> i Fold1: preprocessor 1/1, model 1/2 #> ✓ Fold1: preprocessor 1/1, model 1/2 #> i Fold1: preprocessor 1/1, model 1/2 (extracts) #> i Fold1: preprocessor 1/1, model 1/2 (predictions) #> i Fold1: preprocessor 1/1, model 2/2 #> ✓ Fold1: preprocessor 1/1, model 2/2 #> i Fold1: preprocessor 1/1, model 2/2 (extracts) #> i Fold1: preprocessor 1/1, model 2/2 (predictions) #> i Fold2: preprocessor 1/1 #> ✓ Fold2: preprocessor 1/1 #> i Fold2: preprocessor 1/1, model 1/2 #> ✓ Fold2: preprocessor 1/1, model 1/2 #> i Fold2: preprocessor 1/1, model 1/2 (extracts) #> i Fold2: preprocessor 1/1, model 1/2 (predictions) #> i Fold2: preprocessor 1/1, model 2/2 #> ✓ Fold2: preprocessor 1/1, model 2/2 #> i Fold2: preprocessor 1/1, model 2/2 (extracts) #> i Fold2: preprocessor 1/1, model 2/2 (predictions) #> i Fold3: preprocessor 1/1 #> ✓ Fold3: preprocessor 1/1 #> i Fold3: preprocessor 1/1, model 1/2 #> ✓ Fold3: preprocessor 1/1, model 1/2 #> i Fold3: preprocessor 1/1, model 1/2 (extracts) #> i Fold3: preprocessor 1/1, model 1/2 (predictions) #> i Fold3: preprocessor 1/1, model 2/2 #> ✓ Fold3: preprocessor 1/1, model 2/2 #> i Fold3: preprocessor 1/1, model 2/2 (extracts) #> i Fold3: preprocessor 1/1, model 2/2 (predictions) #> i Fold4: preprocessor 1/1 #> ✓ Fold4: preprocessor 1/1 #> i Fold4: preprocessor 1/1, model 1/2 #> ✓ Fold4: preprocessor 1/1, model 1/2 #> i Fold4: preprocessor 1/1, model 1/2 (extracts) #> i Fold4: preprocessor 1/1, model 1/2 (predictions) #> i Fold4: preprocessor 1/1, model 2/2 #> ✓ Fold4: preprocessor 1/1, model 2/2 #> i Fold4: preprocessor 1/1, model 2/2 (extracts) #> i Fold4: preprocessor 1/1, model 2/2 (predictions) #> i Fold5: preprocessor 1/1 #> ✓ Fold5: preprocessor 1/1 #> i Fold5: preprocessor 1/1, model 1/2 #> ✓ Fold5: preprocessor 1/1, model 1/2 #> i Fold5: preprocessor 1/1, model 1/2 (extracts) #> i Fold5: preprocessor 1/1, model 1/2 (predictions) #> i Fold5: preprocessor 1/1, model 2/2 #> ✓ Fold5: preprocessor 1/1, model 2/2 #> i Fold5: preprocessor 1/1, model 2/2 (extracts) #> i Fold5: preprocessor 1/1, model 2/2 (predictions) #> ✔ Finished tuning Model Specification. #>  #> ℹ Model Parameters: #> # A tibble: 1 × 8 #>   penalty mixture .metric .estimator  mean     n std_err .config              #>     <dbl>   <dbl> <chr>   <chr>      <dbl> <int>   <dbl> <chr>                #> 1  0.0433   0.609 rmse    standard    139.     5    10.0 Preprocessor1_Model2 #>  #> ℹ Prediction Error Comparison: #> # A tibble: 4 × 3 #>   .model_id  rmse .model_desc             #>   <chr>     <dbl> <chr>                   #> 1 1          579. ARIMA(0,1,1)(0,1,1)[12] #> 2 2          381. PROPHET                 #> 3 3          558. GLMNET                  #> 4 ensemble   130. ENSEMBLE (MODEL SPEC)   #>  #> ── Final Model ────────────────────────────────────────────────── #>  #> ℹ Model Workflow: #> ══ Workflow [trained] ══════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: linear_reg() #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 0 Recipe Steps #>  #> ── Model ─────────────────────────────────────────────────────────────────────── #>  #> Call:  glmnet::glmnet(x = maybe_matrix(x), y = y, family = \"gaussian\",      alpha = ~0.609204838849837)  #>  #>    Df  %Dev Lambda #> 1   0  0.00 909.30 #> 2   2  9.93 828.60 #> 3   2 21.08 755.00 #> 4   3 31.51 687.90 #> 5   3 40.66 626.80 #> 6   3 48.55 571.10 #> 7   3 55.36 520.40 #> 8   3 61.20 474.10 #> 9   3 66.21 432.00 #> 10  3 70.50 393.60 #> 11  3 74.16 358.70 #> 12  3 77.29 326.80 #> 13  3 79.96 297.80 #> 14  3 82.22 271.30 #> 15  3 84.15 247.20 #> 16  3 85.79 225.30 #> 17  3 87.19 205.20 #> 18  3 88.37 187.00 #> 19  3 89.38 170.40 #> 20  3 90.23 155.30 #> 21  3 90.96 141.50 #> 22  3 91.58 128.90 #> 23  3 92.11 117.40 #> 24  3 92.56 107.00 #> 25  3 92.94  97.51 #> 26  3 93.27  88.84 #> 27  3 93.55  80.95 #> 28  3 93.79  73.76 #> 29  3 94.00  67.21 #> 30  3 94.18  61.24 #> 31  3 94.33  55.80 #> 32  3 94.46  50.84 #> 33  3 94.58  46.32 #> 34  3 94.68  42.21 #> 35  3 94.76  38.46 #> 36  3 94.83  35.04 #> 37  3 94.89  31.93 #> 38  2 94.94  29.09 #> 39  2 94.97  26.51 #> 40  2 95.00  24.15 #> 41  2 95.02  22.01 #> 42  2 95.04  20.05 #> 43  2 95.05  18.27 #> 44  2 95.06  16.65 #> 45  2 95.07  15.17 #> 46  2 95.08  13.82 #>  #> ... #> and 12 more lines. #>  #> 1.001 sec elapsed #>   ensemble_fit_glmnet #> ── Modeltime Ensemble ─────────────────────────────────────────── #> Ensemble of 3 Models (GLMNET STACK)  #>  #> # Modeltime Table #> # A tibble: 3 × 3 #>   .model_id .model     .model_desc             #>       <int> <list>     <chr>                   #> 1         1 <workflow> ARIMA(0,1,1)(0,1,1)[12] #> 2         2 <workflow> PROPHET                 #> 3         3 <workflow> GLMNET                   # }"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_average.html","id":null,"dir":"Reference","previous_headings":"","what":"Nested Ensemble Average — ensemble_nested_average","title":"Nested Ensemble Average — ensemble_nested_average","text":"Creates Ensemble Model using Mean/Median Averaging Modeltime Nested Forecasting Workflow.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_average.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nested Ensemble Average — ensemble_nested_average","text":"","code":"ensemble_nested_average(   object,   type = c(\"mean\", \"median\"),   keep_submodels = TRUE,   model_ids = NULL,   control = control_nested_fit() )"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_average.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nested Ensemble Average — ensemble_nested_average","text":"object nested modeltime object (inherits class nested_mdl_time) type One \"mean\" mean averaging \"median\" median averaging keep_submodels Whether keep submodels nested modeltime table results model_ids vector id's (.model_id) identifying submodels use ensemble. control Controls various aspects ensembling process. See control_nested_fit().","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_average.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nested Ensemble Average — ensemble_nested_average","text":"nested modeltime table ensemble model added.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_average.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nested Ensemble Average — ensemble_nested_average","text":"start nested modeltime table, can add ensembles.   ensemble can added Nested modeltime table.   can verify model added.   produces ensemble .model_id 3, ensemble first two models.   Additional ensembles can added simply adding onto nested modeltime table. Notice make use model_ids make sure uses model id's 1 2.   returns 4th model median ensemble first two models.","code":"nested_modeltime_tbl  # Nested Modeltime Table Trained on: .splits | Model Errors: [0] # A tibble: 2 x 5   id    .actual_data       .future_data      .splits         .modeltime_tables   <fct> <list>             <list>            <list>          <list> 1 1_1   <tibble [104 x 2]> <tibble [52 x 2]> <split [52|52]> <mdl_time_tbl [2 x 5]> 2 1_3   <tibble [104 x 2]> <tibble [52 x 2]> <split [52|52]> <mdl_time_tbl [2 x 5]> ensem <- nested_modeltime_tbl %>%     ensemble_nested_average(         type           = \"mean\",         keep_submodels = TRUE,         control        = control_nested_fit(allow_par = FALSE, verbose = TRUE)     ) ensem %>% extract_nested_modeltime_table() # A tibble: 4 x 6   id    .model_id .model         .model_desc                 .type .calibration_data   <fct>     <dbl> <list>         <chr>                       <chr> <list> 1 1_1           1 <workflow>     PROPHET                     Test  <tibble [52 x 4]> 2 1_1           2 <workflow>     XGBOOST                     Test  <tibble [52 x 4]> 3 1_1           3 <ensemble [2]> ENSEMBLE (MEAN): 2 MODELS   Test  <tibble [52 x 4]> ensem_2 <- ensem %>%     ensemble_nested_average(         type           = \"median\",         keep_submodels = TRUE,         model_ids      = c(1,2),         control        = control_nested_fit(allow_par = FALSE, verbose = TRUE)     ) ensem_2 %>% extract_nested_modeltime_table() # A tibble: 4 x 6   id    .model_id .model         .model_desc                 .type .calibration_data   <fct>     <dbl> <list>         <chr>                       <chr> <list> 1 1_1           1 <workflow>     PROPHET                     Test  <tibble [52 x 4]> 2 1_1           2 <workflow>     XGBOOST                     Test  <tibble [52 x 4]> 3 1_1           3 <ensemble [2]> ENSEMBLE (MEAN): 2 MODELS   Test  <tibble [52 x 4]> 4 1_1           4 <ensemble [2]> ENSEMBLE (MEDIAN): 2 MODELS Test  <tibble [52 x 4]>"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Nested Ensemble Weighted — ensemble_nested_weighted","title":"Nested Ensemble Weighted — ensemble_nested_weighted","text":"Creates Ensemble Model using Weighted Averaging Modeltime Nested Forecasting Workflow.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nested Ensemble Weighted — ensemble_nested_weighted","text":"","code":"ensemble_nested_weighted(   object,   loadings,   scale_loadings = TRUE,   metric = \"rmse\",   keep_submodels = TRUE,   model_ids = NULL,   control = control_nested_fit() )"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nested Ensemble Weighted — ensemble_nested_weighted","text":"object nested modeltime object (inherits class nested_mdl_time) loadings vector weights corresponding loadings scale_loadings TRUE, divides sum loadings proportionally weight submodels. metric accuracy metric rank models test accuracy table. Loadings applied order best worst models. Default: \"rmse\". keep_submodels Whether keep submodels nested modeltime table results model_ids vector id's (.model_id) identifying submodels use ensemble. control Controls various aspects ensembling process. See control_nested_fit().","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nested Ensemble Weighted — ensemble_nested_weighted","text":"nested modeltime table ensemble model added.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_nested_weighted.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nested Ensemble Weighted — ensemble_nested_weighted","text":"start nested modeltime table, can add ensembles.   ensemble can added Nested modeltime table.   can verify model added.   produces ensemble .model_id 3, ensemble first two models.   can verify loadings applied correctly. Note loadings applied based model lowest RMSE.   Note xgboost model gets 66% loading prophet gets 33% loading. xgboost lower RMSE case.","code":"nested_modeltime_tbl  # Nested Modeltime Table Trained on: .splits | Model Errors: [0] # A tibble: 2 x 5   id    .actual_data       .future_data      .splits         .modeltime_tables   <fct> <list>             <list>            <list>          <list> 1 1_1   <tibble [104 x 2]> <tibble [52 x 2]> <split [52|52]> <mdl_time_tbl [2 x 5]> 2 1_3   <tibble [104 x 2]> <tibble [52 x 2]> <split [52|52]> <mdl_time_tbl [2 x 5]> ensem <- nested_modeltime_tbl %>%     ensemble_nested_weighted(         loadings       = c(2,1),         control        = control_nested_fit(allow_par = FALSE, verbose = TRUE)     ) ensem %>% extract_nested_modeltime_table() # A tibble: 4 x 6   id    .model_id .model         .model_desc                   .type .calibration_data   <fct>     <dbl> <list>         <chr>                         <chr> <list> 1 1_3           1 <workflow>     PROPHET                       Test  <tibble [52 x 4]> 2 1_3           2 <workflow>     XGBOOST                       Test  <tibble [52 x 4]> 3 1_3           3 <ensemble [2]> ENSEMBLE (WEIGHTED): 2 MODELS Test  <tibble [52 x 4]> ensem %>%     extract_nested_modeltime_table(1) %>%     slice(3) %>%     pluck(\".model\", 1) -- Modeltime Ensemble -------------------------------------------     Ensemble of 2 Models (WEIGHTED)  # Modeltime Table # A tibble: 2 x 6   .model_id .model     .model_desc .type .calibration_data .loadings       <int> <list>     <chr>       <chr> <list>                <dbl> 1         1 <workflow> PROPHET     Test  <tibble [52 x 4]>     0.333 2         2 <workflow> XGBOOST     Test  <tibble [52 x 4]>     0.667"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a Weighted Ensemble Model — ensemble_weighted","title":"Creates a Weighted Ensemble Model — ensemble_weighted","text":"Makes ensemble applying loadings weight sub-model predictions","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a Weighted Ensemble Model — ensemble_weighted","text":"","code":"ensemble_weighted(object, loadings, scale_loadings = TRUE)"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a Weighted Ensemble Model — ensemble_weighted","text":"object Modeltime Table loadings vector weights corresponding loadings scale_loadings TRUE, divides sum loadings proportionally weight submodels.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a Weighted Ensemble Model — ensemble_weighted","text":"mdl_time_ensemble object.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_weighted.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a Weighted Ensemble Model — ensemble_weighted","text":"input ensemble_weighted() model always Modeltime Table, contains models ensemble. Weighting Method weighted method uses uses loadings applying loading x model prediction submodel.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/ensemble_weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a Weighted Ensemble Model — ensemble_weighted","text":"","code":"# \\donttest{ library(tidymodels) library(modeltime) library(modeltime.ensemble) library(dplyr) library(timetk)  # Make an ensemble from a Modeltime Table ensemble_fit <- m750_models %>%     ensemble_weighted(         loadings = c(3, 3, 1),         scale_loadings = TRUE     )  ensemble_fit #> ── Modeltime Ensemble ─────────────────────────────────────────── #> Ensemble of 3 Models (WEIGHTED)  #>  #> # Modeltime Table #> # A tibble: 3 × 4 #>   .model_id .model     .model_desc             .loadings #>       <int> <list>     <chr>                       <dbl> #> 1         1 <workflow> ARIMA(0,1,1)(0,1,1)[12]     0.429 #> 2         2 <workflow> PROPHET                     0.429 #> 3         3 <workflow> GLMNET                      0.143  # Forecast with the Ensemble modeltime_table(     ensemble_fit ) %>%     modeltime_forecast(         new_data    = testing(m750_splits),         actual_data = m750     ) %>%     plot_modeltime_forecast(         .interactive = FALSE,         .conf_interval_show = FALSE     ) #> Warning: There were 2 warnings in `dplyr::mutate()`. #> The first warning was: #> ℹ In argument: `.nested.col = purrr::map2(...)`. #> Caused by warning: #> ! There was 1 warning in `dplyr::mutate()`. #> ℹ In argument: `.nested.col = purrr::map2(...)`. #> Caused by warning: #> ! `keep_original_cols` was added to `step_dummy()` after this recipe was created. #> ℹ Regenerate your recipe to avoid this warning. #> ℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.  # }"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://business-science.github.io/modeltime.ensemble/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"function call","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/tidyeval.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy eval helpers — tidyeval","title":"Tidy eval helpers — tidyeval","text":"sym() creates symbol string syms() creates list symbols character vector. enquo() enquos() delay execution one several function arguments. enquo() returns single quoted expression, like blueprint delayed computation. enquos() returns list quoted expressions. expr() quotes new expression locally. mostly useful build new expressions around arguments captured enquo() enquos(): expr(mean(!!enquo(arg), na.rm = TRUE)). as_name() transforms quoted variable name string. Supplying something else quoted variable name error. unlike as_label() also returns single string supports kind R object input, including quoted function calls vectors. purpose summarise object single label. label often suitable default name. know quoted expression contains (instance expressions captured enquo() variable name, call function, unquoted constant), use as_label(). know quoted simple variable name, like enforce , use as_name(). learn tidy eval use tools, visit Metaprogramming section Advanced R.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/reference/tidyeval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidy eval helpers — tidyeval","text":"Nothing.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-development-version","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble (development version)","title":"modeltime.ensemble (development version)","text":"#31 Fixes issue metric argument specified:","code":"Error in `tune::show_best()`: ! `...` must be empty. ✖ Problematic argument: • ..1 = metric ℹ Did you forget to name an argument?"},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-103","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 1.0.3","title":"modeltime.ensemble 1.0.3","text":"CRAN release: 2023-04-18 Resubmit CRAN (following timetk archival)","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-102","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 1.0.2","title":"modeltime.ensemble 1.0.2","text":"CRAN release: 2022-10-18 Update tests workflows mode = “regression”","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-101","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 1.0.1","title":"modeltime.ensemble 1.0.1","text":"CRAN release: 2022-06-09","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"fixes-1-0-1","dir":"Changelog","previous_headings":"","what":"Fixes","title":"modeltime.ensemble 1.0.1","text":"Updates hardhat 1.0.0","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-100","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 1.0.0","title":"modeltime.ensemble 1.0.0","text":"CRAN release: 2021-10-19","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"new-nested-modeltime-ensembles-1-0-0","dir":"Changelog","previous_headings":"","what":"NEW Nested Modeltime Ensembles","title":"modeltime.ensemble 1.0.0","text":"modeltime 1.0.0, introduced Nested Forecasting way forecast many time series iteratively. modeltime.ensemble 1.0.0, introduce nested ensembles can improve forecasting performance applied many time series iteratively. added: ensemble_nested_average(): Apply average ensembles iteratively ensemble_nested_weighted(): Apply weighted ensembles iteratively","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"new-vignette-nested-ensembles-1-0-0","dir":"Changelog","previous_headings":"","what":"New Vignette (Nested Ensembles)","title":"modeltime.ensemble 1.0.0","text":"Nested Ensembles","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-042","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 0.4.2","title":"modeltime.ensemble 0.4.2","text":"CRAN release: 2021-07-16","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"compatibility-with-modeltime-0-4-2","dir":"Changelog","previous_headings":"","what":"Compatibility with modeltime 0.7.0.","title":"modeltime.ensemble 0.4.2","text":"Calibration: Added “id” feature enable accuracy confidence intervals time series ID.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-041","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 0.4.1","title":"modeltime.ensemble 0.4.1","text":"CRAN release: 2021-05-31 Improvements parallel processing refitting (available modeltime 0.6.0). Requires modeltime 0.6.0 parsnip 0.1.6 align xgboost upgrades.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-040","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 0.4.0","title":"modeltime.ensemble 0.4.0","text":"CRAN release: 2021-04-05 Recursive Ensembles recursive() - recursive() function extended recursive ensembles single time series multiple time series models (panel data). “Forecasting Recursive Ensembles” - new forecasting vignette using recurive() ensembles. Fixes modeltime_forecast() now returns NA missing values present sub-model predictions.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-030","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 0.3.0","title":"modeltime.ensemble 0.3.0","text":"CRAN release: 2020-11-06 Panel Data Improvements made ensemble_average(), ensemble_weighted() ensemble_model_spec() support Panel Data (.e. data sets multiple time series groups possibly overlapping time stamps). Changes modeltime.ensemble now depends modeltime.resample modeltime_fit_resamples() functionality. modeltime_fit_resamples() moved new package modeltime.resample. ensemble_weighted(): Now removes models weight (e.g. loading = 0). speeds refitting.","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-020","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 0.2.0","title":"modeltime.ensemble 0.2.0","text":"CRAN release: 2020-10-09 Stacked Ensembles (Breaking Changes) process creating stacked ensembles split 2 steps: Step 1: Use modeltime_fit_resamples() generate resampled predictions Step 2: Use ensemble_model_spec() apply stacking using model_spec Note - modeltime_refit(stacked_ensemble) still one step, best way handle refitting since multiple stacked models may different submodel compositions. additional argument, resamples can provided train stacked ensembles made ensemble_model_spec().","code":""},{"path":"https://business-science.github.io/modeltime.ensemble/news/index.html","id":"modeltimeensemble-010","dir":"Changelog","previous_headings":"","what":"modeltime.ensemble 0.1.0","title":"modeltime.ensemble 0.1.0","text":"CRAN release: 2020-10-07 Initial release modeltime.ensemble.","code":""}]
